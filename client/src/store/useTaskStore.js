import { create } from 'zustand';
import axios from 'axios';
import BACKEND_URL from '../../Config';
import { toast } from 'react-toastify';
import { useAuthStore } from './useAuthStore';
import { useFocusStore } from './useFocusStore';

export const useTaskStore = create((set, get) => ({
    tasks: [],
    qtasks: [],
    loadingTasks: false,
    error: null,

    fetchTasks: async () => {
        set({ loadingTasks: true, error: null });
        const token = useAuthStore.getState().token;
        if (!token) {
            set({ loadingTasks: false });
            // Optionally redirect or handle no token
            return;
        }

        try {
            const [taskRes, qtaskRes] = await Promise.all([
                axios.get(`${BACKEND_URL}/api/tasks`, { headers: { Authorization: `Bearer ${token}` } }),
                axios.get(`${BACKEND_URL}/api/qtasks`, { headers: { Authorization: `Bearer ${token}` } }),
            ]);
            set({
                tasks: Array.isArray(taskRes.data) ? taskRes.data : (taskRes.data || []),
                qtasks: Array.isArray(qtaskRes.data) ? qtaskRes.data : (qtaskRes.data || []),
                loadingTasks: false,
            });
        } catch (err) {
            console.error('Failed fetching tasks', err);
            set({ error: err.response?.data?.message || 'Failed to fetch tasks', loadingTasks: false });
            if (err.response?.status === 401) {
                toast.error('Session expired. Please log in again.');
                useAuthStore.getState().logout();
            }
        }
    },

    setTasksLocally: (tasks) => set({ tasks }),
    setQTasksLocally: (qtasks) => set({ qtasks }),

    saveTask: async (task, isEdit = false) => {
        const token = useAuthStore.getState().token;
        if (!token) return;

        // Optimistic Update
        const originalTasks = get().tasks;
        let tempId = null;

        if (isEdit) {
            set((state) => ({
                tasks: state.tasks.map(t => (t.id === task.id ? task : t))
            }));
        } else {
            // For new task, we need a temp ID if not provided, or use the one generated by frontend usually
            // TaskForm usually generates a UUID, so we can use that.
            set((state) => ({ tasks: [...state.tasks, task] }));
        }

        try {
            const method = isEdit ? 'put' : 'post';
            const url = isEdit ? `${BACKEND_URL}/api/tasks/${task.id}` : `${BACKEND_URL}/api/tasks`;
            const res = await axios[method](url, task, { headers: { Authorization: `Bearer ${token}` } });
            const saved = res.data;

            // Update with server response (which might have created_at, id etc corrected)
            set((state) => {
                if (isEdit) {
                    return { tasks: state.tasks.map(t => (t.id === saved.id ? saved : t)) };
                } else {
                    // Replace the optimistic task with the real one (matching by ID if we stuck to uuid, or if ID changed we might have an issue)
                    // Assuming ID from frontend (uuid) is respected or we need to find by some other means?
                    // If backend overwrites ID, we have a problem matching. 
                    // Usually in this app context, let's assume simple replacement or just update.
                    // If backend sends back a NEW id different from frontend uuid, we must swap.
                    // For now, let's just map over.
                    return { tasks: state.tasks.map(t => (t.id === task.id ? saved : t)) };
                }
            });

            // Handle Focus Mode
            if (useFocusStore.getState().isFocusMode && saved.status === 'completed') {
                useFocusStore.getState().addCompletedTask(saved);
            }

            toast.success(isEdit ? 'Task updated' : 'Task created');
            return saved;
        } catch (err) {
            console.error('saveTask failed', err);
            toast.error('Failed to save task');
            // Revert optimistic update
            set({ tasks: originalTasks });
            throw err;
        }
    },

    deleteTask: async (taskId) => {
        const token = useAuthStore.getState().token;
        const originalTasks = get().tasks;

        // Optimistic
        set((state) => ({ tasks: state.tasks.filter(t => t.id !== taskId) }));

        try {
            await axios.delete(`${BACKEND_URL}/api/tasks/${taskId}`, { headers: { Authorization: `Bearer ${token}` } });
            toast.success('Task deleted');
        } catch (err) {
            console.error('deleteTask failed', err);
            toast.error('Failed to delete task');
            set({ tasks: originalTasks });
        }
    },

    markTaskCompleted: async (taskId) => {
        const task = get().tasks.find(t => t.id === taskId);
        if (!task) return;

        const originalTasks = get().tasks;

        // Optimistic
        const updatedLocal = get().tasks.map(t => (t.id === taskId ? { ...t, status: 'completed' } : t));
        set({ tasks: updatedLocal });

        // Update Focus Store
        if (useFocusStore.getState().isFocusMode) {
            useFocusStore.getState().addCompletedTask({ ...task, status: 'completed' });
        }

        const token = useAuthStore.getState().token;
        try {
            await axios.put(`${BACKEND_URL}/api/tasks/${taskId}`, { ...task, status: 'completed' }, { headers: { Authorization: `Bearer ${token}` } });
        } catch (err) {
            console.error('Failed to update task on server', err);
            toast.error('Failed to update task on server');
            set({ tasks: originalTasks });
        }
    },
}));
